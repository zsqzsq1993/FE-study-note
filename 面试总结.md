# 面试总结

## 关于dolly-music项目

1. 如何用邮箱进行验证码验证的

采用邮箱发送验证码进行验证。点击发送验证码后，前端会通过ajax将邮箱地址发送到后端，后端通过ioredis插件链接redis服务。通过`Math.random().toString(16).slice(2,4).toUpperCase()`来生成验证码，通过nodemail插件将验证码发送至邮箱，并在redis中用hset保存邮箱为大key，分别保存验证码和过期时间两个字段以便后期验证。将来在提交表单，或通过ajax发送请求验证时，就能够通过mail的地址，从redis中通过hget取出验证码以及过期时间进行验证。

2. 开发过哪些另自己印象深刻的基础组件？

1）scroll组件，scroll组件的原理是外层有一个wrapper，是固定高度的。内层的wrapper通过slot留给使用者插入，它的高度是由内容撑开的。在scroll组件中，封装了better-scroll的各个功能，包括监听滚动，是否滚动到顶点或底点等。

## 关于free-drag项目

1）为何要摒弃原生的DragEvent？

因为原生的DragEvent是继承与MouseEvent的，在移动端不能很好的起作用

2）原生的DragEvent有哪一些事件？

dragstart：拖拽开始

dragend：拖拽结束

drag：拖拽时每几百毫秒触发一次

dragenter：target会指向被拖动元素下方的元素，该功能的pollyfill可以通过：document.elementFromPoint找到拖动位置最近的HTMLElement，然后通过element.closest()这个选择器来查找

dragleave：该事件与dragenter事件相似

dragover：与dragenter触发相似，但不是进入触发，而是进入后每几百毫秒触发一次

## 关于dolly-take-away

1）下落小球的实现：

在文档树中添加5个小球的节点（HTMLELEMENT）并隐藏。设置一个按钮来控制下落，点击按钮时，选取一个隐藏的球并添加入一个数组。通过vue的javascript动画钩子，在beforeEnter和enter中，分别设置transform，如果想从点击处下落在beforeEnter中还要设置position。并在afterEnter中，将小球再次设置为隐藏并从数组中拿出，恢复待用状态。设置5个小球节点的原因是避免频繁的点击，5个球节点保证了一个小球的过渡动画还未完成时就触发了另一个动画，有闲置的小球可供下落。

## 关于dolly-axios

1. url中采用的是什么编码？为何要进行字符串的编码？

采用的ASCII编码。编码的原因是1. url中无法携带中文，可以将中文进行编码进行传递； 2. url中携带&或=等特殊字符作为普通字符使用时容易产生歧义，编码可以消除歧义。

2. 是如何对params进行处理的

1）判断是否有hash符，有的话去掉

2）数组的key值要加[]，如key[]

3）Date对象，调用toISOString方法

4）Object对象，调用JSON.stringfy转变为字符串

5）对key和value分别进行ASCII码编码再通过=进行拼接

6）编码手段主要使用encodeURIComponent，对于某些特殊字符串，再进行解码（不进行编码如@,[,]）

## 高频的面试题

1. clientHeight和offsetHeight

clientHeight包含content、padding但不包含border以及滚动条

offsetHeight包含content、padding、border以及滚动条。两者都不包含margin

2. foo&getName

```javascript
function Foo(){
    getName = function(){
        console.log(1);
    };
    return this;
} 

Foo.getName = function(){
    console.log(2);
}

Foo.prototype.getName = function(){
    console.log(3);
}

var getName = function(){
    console.log(4);
}

function getName(){
    console.log(5);}

//输出以下的输出结果

//函数Foo的静态方法
Foo.getName();//2

//function getName有提前声明的规则，声明后被var getName= 。。覆盖，则getName为4
getName();//4

//Foo()的return this为window，window.getName 在Foo里面被覆盖，则输出1
Foo().getName();//1

//同上，因调用了Foo();window的getName被覆盖
getName();//1

//依然只是调用了Foo对象上的getName,又因为Foo.getNname，所以相当于
/**
 *  function a(){console.log(2)};
 *  new a();
 * **/
new Foo.getName();//2

//先执行了new Foo()；返回一个对象，这个对象的getName为prototype上的getName,相当于(new Foo()).getName();
new Foo().getName();//3

//
new new Foo().getName();//3
```

## Vue面试题

1. v-if和v-show的区别

两者区别在于v-if才是真正的条件渲染，它会导致组件下vnode所对应的dom元素重写创建或者销毁。

而v-show则是通过css来实现的。

2. Computed, method或watch的区别

computed是在函数内进行一番计算后返回一个值。返回的值会根据计算中出现的值动态的改变，可以理解为一个动态的data。

method若作为data使用也是动态的，但是它无法缓存，但computed却可以。

watch是指观测一个值的变化，当该值发生变化后执行某些具体的操作。

3. 为何